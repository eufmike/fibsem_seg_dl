import os, glob
import numpy as np
import math
import uuid
from skimage.io import imread, imsave, imshow
from PIL import Image, ImageTk
from typing import Union, Any, List, Tuple
from tqdm.notebook import trange
import matplotlib.pyplot as plt
import itertools
from pprint import pprint

def dir_checker(folder_name, path):
    if not folder_name in os.listdir(path):
        print('{} does not exist in {}'.format(folder_name, path))
        os.mkdir(os.path.join(path, folder_name))
    else: 
        print('{} exists in {}'.format(folder_name, path))

def random_crop(imgs, random_range, seed=None):
    # Note: image_data_format is 'channel_last'
    # assert img.shape[2] == 3
    height, width = imgs[0].shape
    
    range_low = random_range[0]
    range_high = random_range[1] + 1

    if seed is not None:    
        np.random.seed(seed + 10)
        dx = np.random.randint(range_low, range_high)
        np.random.seed(seed + 10 + 1)
        dy = np.random.randint(range_low, range_high)
        
        np.random.seed(seed + 20)
        x = np.random.randint(0, width - dx + 1)
        np.random.seed(seed + 20 + 1)
        y = np.random.randint(0, height - dy + 1)
       
    else:
        dx = np.random.randint(range_low, range_high)
        dy = np.random.randint(range_low, range_high)
        x = np.random.randint(0, width - dx + 1)
        y = np.random.randint(0, height - dy + 1)
    
    imgs_crop = []
    for img in imgs: 
        img_tmp = img[y:(y+dy), x:(x+dx)]
        imgs_crop.append(img_tmp)
    
    return imgs_crop

def random_crop_3D(imgs, crop_size, seed=None):
    # Note: image_data_format is 'channel_last'
    # assert img.shape[2] == 3
    depth, height, width = imgs[0].shape
    
    dz = crop_size[0]
    dy = crop_size[1]
    dx = crop_size[2]
    
    if seed is not None:
        
        if depth == dz: 
            z = 0
        else:
            np.random.seed(seed + 20)
            z = np.random.randint(0, depth - dz + 1)
        np.random.seed(seed + 20 + 1)
        y = np.random.randint(0, height - dy + 1)
        np.random.seed(seed + 20 + 2)
        x = np.random.randint(0, width - dx + 1)
    else:
        if depth == dz: 
            z = 0
        else:
            z = np.random.randint(0, depth - dz + 1)
        y = np.random.randint(0, height - dy + 1)
        x = np.random.randint(0, width - dx + 1)
        
    
    imgs_crop = []
    for img in imgs: 
        img_tmp = img[z:(z+dz), y:(y+dy), x:(x+dx)]
        imgs_crop.append(img_tmp)
    
    return imgs_crop

def crop_generator(batches, crop_length):
    """Take as input a Keras ImageGen (Iterator) and generate random
    crops from the image batches generated by the original iterator.
    """
    while True:
        batch_x, batch_y = next(batches)
        batch_crops = np.zeros((batch_x.shape[0], crop_length, crop_length, 3))
        for i in range(batch_x.shape[0]):
            batch_crops[i] = random_crop(batch_x[i], (crop_length, crop_length))
        yield (batch_crops, batch_y)

def crop_image_only_outside(label, img, tol=0, pad=256):
    # img is 2D image data
    # tol  is tolerance
    label = np.pad(label, ((pad, pad), (pad, pad)), 'constant', constant_values=0)
    img = np.pad(img, ((pad, pad), (pad, pad)), 'constant', constant_values=0)
    mask = label > tol
    m, n = label.shape
    mask0, mask1 = mask.any(0), mask.any(1)
    col_start, col_end = mask0.argmax() - pad, n-mask0[::-1].argmax() + pad
    row_start, row_end = mask1.argmax() - pad, m-mask1[::-1].argmax() + pad
    return (label[row_start:row_end,col_start:col_end], img[row_start:row_end,col_start:col_end])
        
def random_crop_batch(ipimglist, 
                      iplabellist, 
                      opfolder, 
                      label, 
                      crop_size, 
                      crop_per_image, 
                      crop_outside = False,
                      seed=None):
    '''
    Takes images in the input folder("ipfolder") and randomly crop the images in batch, and 
    save to the output folder("opfolder"). The range of cropping size can be defined by 
    "random_size_range". "crop_per_image" defines the amount of images generated from 
    each inputs. 
    '''
    
    # create the file list
    imglist = ipimglist[label]
    labellist = iplabellist[label]
    
    total_img_count = len(imglist) * crop_per_image
    
    id_count = 1
    
    if not len(imglist) == len(labellist):
        print(len(imglist))
        print(len(labellist))
    
    # iterate through each files
    for idx in trange(len(imglist)): 
        ip_img_filename = imglist[idx] 
        ip_label_filename = labellist[idx]  
      
        # load the raw images
        img_tmp = imread(ip_img_filename, as_gray=True)
        
        # load the labeled images
        label_tmp = imread(ip_label_filename, as_gray=True)
        # plt.imshow(label_tmp)
        
        # Incase there are labels bigger than 1
        label_tmp_array = label_tmp > 0 

        if crop_outside: 
            label_tmp_array, img_tmp_array = crop_image_only_outside(label_tmp_array, img_tmp)
        else: 
            img_tmp_array = img_tmp
            label_tmp_array = label_tmp_array
        
        # print(label_tmp_array.shape)
        # plt.imshow(img_tmp_array)
        # plt.imshow(label_tmp_array)
        
        # while subimg_count < (crop_per_image + 1):        
        for i in range(crop_per_image):
            # crop the image by a give value
            imgs_crop = random_crop([img_tmp_array, label_tmp_array], crop_size, seed=seed)
            img_crop = imgs_crop[0]
            label_crop = imgs_crop[1]
            # plt.imshow(label_crop)
            
            # percentage = np.sum(label_crop)/(crop_size[0] * crop_size[1])
            
            # save image
            pil_img_crop = Image.fromarray(img_crop)
            pil_label_crop = Image.fromarray(label_crop)

            id_name = str(id_count)
            pil_img_crop.save(os.path.join(opfolder, 'images', label, id_name.zfill(4) + '.tif'))
            pil_label_crop.save(os.path.join(opfolder, 'labels', label, id_name.zfill(4) + '.tif'))

            id_count += 1
         
            if seed is not None:
                seed += 1

def random_crop_batch_3D(ipimglist, 
                      iplabellist, 
                      opfolder, 
                      label, 
                      crop_size, 
                      crop_per_image, 
                      seed=None):
    '''
    Takes images in the input folder("ipfolder") and randomly crop the images in batch, and 
    save to the output folder("opfolder"). The range of cropping size can be defined by 
    "random_size_range". "crop_per_image" defines the amount of images generated from 
    each inputs. 
    '''
    
    print('start random_crop_batch_3D')
    
    # create the file list
    imglist = ipimglist[label]
    labellist = iplabellist[label]
    
    total_img_count = len(imglist) * crop_per_image
    
    # iterate through each files
    for idx in trange(len(imglist)): 
        # load the raw images
        # print(imglist)
        img_tmp_list = glob.glob(os.path.join(imglist[idx], '*.tif'), recursive=True)
        # pprint(img_tmp_list)
        img_tmp = volume_loader(img_tmp_list)
        
        # load the labeled images
        label_tmp_list = glob.glob(os.path.join(labellist[idx], '*.tif'), recursive=True)
        label_tmp = volume_loader(label_tmp_list)
        # plt.imshow(label_tmp)
        
        # Incase there are labels bigger than 1
        label_tmp_array = label_tmp > 0 
       
        img_tmp_array = img_tmp.astype('uint8')
        label_tmp_array = label_tmp_array.astype('uint8')
        
        print(label_tmp_array.shape)
        
        # plt.imshow(img_tmp_array)
        # plt.imshow(label_tmp_array)
        
        # while subimg_count < (crop_per_image + 1):        
        for i in range(crop_per_image):
            # crop the image by a give value
            imgs_crop = random_crop_3D([img_tmp_array, label_tmp_array], crop_size, seed=seed)
            imgs_crop = imgs_crop.astype('uint8')
            print(imgs_crop.dtype)
            img_crop = imgs_crop[0]
            label_crop = imgs_crop[1]
            # plt.imshow(label_crop)
            
            # percentage = np.sum(label_crop)/(crop_size[0] * crop_size[1])
            
            
            loc_name = str(i+1)

            dir_checker(loc_name.zfill(4), os.path.join(opfolder, 'images', label))
            dir_checker(loc_name.zfill(4), os.path.join(opfolder, 'labels', label))
            
            for j in range(img_crop.shape[0]): 
                # save image
                pil_img_crop = Image.fromarray(img_crop[j], mode = 'L')
                pil_label_crop = Image.fromarray(label_crop[j], mode = 'L')

                id_name = str(j+1)
                
                pil_img_crop.save(os.path.join(opfolder, 'images', label, loc_name.zfill(4), id_name.zfill(4) + '.tif'))
                pil_label_crop.save(os.path.join(opfolder, 'labels', label, loc_name.zfill(4), id_name.zfill(4) + '.tif'))

            if seed is not None:
                seed += 1
            
                
def volume_loader(ipimglist):
    '''
    load the image volume
    '''
    img_0 = imread(ipimglist[0], as_gray=True)
    
    # create the file list 
    img_zdim = len(ipimglist)
    img_ydim = img_0.shape[0]
    img_xdim = img_0.shape[1]
    
    img_stack = np.zeros((img_zdim, img_ydim, img_xdim))
    for z_idx in trange(img_zdim):
        img_tmp = imread(ipimglist[z_idx], as_gray=True)
        img_stack[z_idx] = img_tmp

    return img_stack

def sampler_3D(img_stack,
               crop_size, 
               crop_per_image, 
               seed = None):
    
    img_zdim, img_ydim, img_xdim = img_stack.shape
    # print((img_zdim, img_ydim, img_xdim))
    crop_z_size, crop_y_size, crop_x_size = crop_size
    
    if seed is None:
        z_idx_start = np.random.randint(0, img_zdim - crop_z_size + 1)
        y_idx_start = np.random.randint(0, img_ydim - crop_y_size + 1)
        x_idx_start = np.random.randint(0, img_xdim - crop_x_size + 1)
    else: 
        np.random.seed(seed)
        z_idx_start = np.random.randint(0, img_zdim - crop_z_size + 1)
        np.random.seed(seed + 1)
        y_idx_start = np.random.randint(0, img_ydim - crop_y_size + 1)
        np.random.seed(seed + 2)
        x_idx_start = np.random.randint(0, img_xdim - crop_x_size + 1)

    opidx = np.empty((0, 6), int)
    
    opidx_list = [z_idx_start, 
                y_idx_start,
                x_idx_start, 
                z_idx_start + crop_z_size,
                y_idx_start + crop_y_size, 
                x_idx_start + crop_x_size
                ] 
    
    # print(opidx_list)
    
    opidx = np.append(opidx, np.array([opidx_list]), axis = 0)
    
    # print(opidx)
    
    temp_seed = seed + 100
    for img_idx in range(crop_per_image - 1):
        
        
        if seed is None: 
            z_idx_start = np.random.randint(0, img_zdim - crop_z_size + 1)
            y_idx_start = np.random.randint(0, img_ydim - crop_y_size + 1)
            x_idx_start = np.random.randint(0, img_xdim - crop_x_size + 1)
            
        else:     
            temp_seed = ((temp_seed + 0))
            np.random.seed(temp_seed)
            z_idx_start = np.random.randint(0, img_zdim - crop_z_size + 1)
            np.random.seed(temp_seed + 1)
            y_idx_start = np.random.randint(0, img_ydim - crop_y_size + 1)
            np.random.seed(temp_seed + 2)
            x_idx_start = np.random.randint(0, img_xdim - crop_x_size + 1)
        
        z_idx_s = [z_idx_start, z_idx_start + crop_z_size]
        y_idx_s = [y_idx_start, y_idx_start + crop_y_size]
        x_idx_s = [x_idx_start, x_idx_start + crop_x_size]
        
        point_list = list(itertools.product(z_idx_s, y_idx_s, x_idx_s))
        
        point_count = 0
        for point in point_list:
            for poidx_idx in range(opidx.shape[0]):
                tmp_boarder = opidx[poidx_idx]
                if (point[0] > tmp_boarder[0] and point[0] < tmp_boarder[3] and 
                    point[1] > tmp_boarder[1] and point[1] < tmp_boarder[4] and 
                    point[2] > tmp_boarder[2] and point[2] < tmp_boarder[5]):
                    # print('overlap')
                    break
            point_count += 1
            
        if point_count == 8:
            tmp_point = [z_idx_s[0],
                         y_idx_s[0],
                         x_idx_s[0],
                         z_idx_s[1],
                         y_idx_s[1],
                         x_idx_s[1]
                         ]
            # print(tmp_point)
            opidx = np.append(opidx, np.array([tmp_point]), axis = 0)
        
        temp_seed += 1
        
    return opidx

def patch_sampler_3D(ipimglist,
                     opfolder,
                     crop_size,
                     crop_per_image,
                     crop_outside = False,
                     seed=None):
    '''
    Takes images in the input folder and randomly crop the images in volume in 3D with no overlap, 
    then save to the output folder("opfolder"). The range of cropping size can be defined by 
    "crop_size". "crop_per_image" defines the amount of images generated from 
    each inputs. 
    '''
    # load the first image
    img_0 = imread(ipimglist[0], as_gray=True)
    
    # create the file list 
    img_zdim = len(ipimglist)
    img_ydim = img_0.shape[0]
    img_xdim = img_0.shape[1]
    total_size = float(img_zdim * img_ydim * img_xdim)
    
    print('image z size: {}'.format(img_zdim))
    print('image y size: {}'.format(img_ydim))
    print('image x size: {}'.format(img_xdim))
    print('total size: {}'.format(total_size))
    
    total_crop_size = crop_size[0] * crop_size[1] * crop_size[2] * crop_per_image
    print('total crop size: {}'.format(total_crop_size))
    
    # calculate percentage    
    percentage = total_crop_size * 100/total_size
    
    print('Occupied {}% of total volume'.format(percentage))
    
    # loading image
    print('Loading images...')
    img_stack = np.zeros((img_zdim, img_ydim, img_xdim))
    for z_idx in trange(img_zdim):
        img_tmp = imread(ipimglist[z_idx], as_gray=True)
        img_stack[z_idx] = img_tmp
    
    # create crop idx
    print('Crop per image: {}'.format(crop_per_image))
    print('Sampling image...')
    crop_idx_3D = sampler_3D(img_stack = img_stack,
               crop_size = crop_size, 
               crop_per_image = crop_per_image, 
               seed = seed)
    
    # crop image
    print('Cropping image in 3D...')
    volume_crop = np.zeros((crop_per_image, crop_size[0], crop_size[1], crop_size[2]))
    
    for idx in trange(crop_per_image):
        idx_tmp = crop_idx_3D[idx]
        print(idx_tmp)
        volume_crop[idx] = img_stack[idx_tmp[0]:idx_tmp[3], 
                                     idx_tmp[1]:idx_tmp[4],
                                     idx_tmp[2]:idx_tmp[5]
                                    ]
    # save image 
    print('Saving cropping volume')
    for idx in trange(crop_per_image):
        foldername = str(idx).zfill(4)
        dir_checker(foldername, opfolder)
        for z_idx in range(crop_size[0]):
            img_tmp = volume_crop[idx, z_idx]
            pil_img_tmp = Image.fromarray(img_tmp)
            pil_img_tmp.save(os.path.join(opfolder, foldername, str(z_idx).zfill(4) + '.tif'))
    
    
def create_crop_idx(img_size, target_size = (256, 256), overlap_fac = 0.1):
    '''
    img_size: the size(shape) of input image
    IMG_HEIGHT, IMG_WIDTH: height and width for the training network
    Cropping rule: from top-left to bottom-right, row first
    '''
    
    img_y = img_size[0]
    img_x = img_size[1]
    IMG_HEIGHT = target_size[0]
    IMG_WIDTH = target_size[1]
    overlap_fac = overlap_fac
    
    overlap_y = round(target_size[0] * overlap_fac) #overlap pixel
    step_y = target_size[0] - overlap_y # step size    
    
    y_step_c = math.ceil((img_y - IMG_HEIGHT) / step_y) + 1
    y_rem = (img_y - IMG_HEIGHT) % step_y 

    overlap_x = round(target_size[1] * overlap_fac) #overlap pixel
    step_x = target_size[1] - overlap_x # step size    
    
    x_step_c = math.ceil((img_x - IMG_WIDTH) / step_x) + 1
    x_rem = (img_x - IMG_WIDTH) % step_x 
    
    outputidx = np.empty((0, 6), int)
    
    ## create crop index
    # for imgidx_y in trange(y_step_c):  
    for imgidx_y in range(y_step_c): 
        if (imgidx_y+1)%y_step_c != 0:
            start_y = imgidx_y*step_y
            end_y = imgidx_y*step_y+IMG_HEIGHT
            for imgidx_x in range(x_step_c):    
                if (imgidx_x+1)%x_step_c != 0:
                    start_x = imgidx_x*step_x
                    end_x = imgidx_x*step_x+IMG_WIDTH
                    outputidx = np.append(outputidx, 
                                                np.array([[start_y, end_y, 
                                                           start_x, end_x, 
                                                           imgidx_y, imgidx_x]]), axis=0)
                else:
                    start_x = img_x-IMG_WIDTH
                    end_x = img_x
                    outputidx = np.append(outputidx, 
                                                np.array([[start_y, end_y, 
                                                           start_x, end_x, 
                                                           imgidx_y, imgidx_x]]), axis=0)
        else: 
            start_y = img_y-IMG_HEIGHT
            end_y = img_y
            for imgidx_x in range(x_step_c): 
                if (imgidx_x+1)%x_step_c != 0:
                    start_x = imgidx_x*step_x
                    end_x = imgidx_x*step_x+IMG_WIDTH
                    outputidx = np.append(outputidx, 
                                                np.array([[start_y, end_y, 
                                                           start_x, end_x, 
                                                           imgidx_y, imgidx_x]]), axis=0)
                else:
                    start_x = img_x-IMG_WIDTH
                    end_x = img_x
                    outputidx = np.append(outputidx, 
                                                np.array([[start_y, end_y, 
                                                           start_x, end_x, 
                                                           imgidx_y, imgidx_x]]), axis=0)  
    
    # print("Image Shape: {}, {}".format(img_y, img_x))
    # print("Patch size: {}, {}".format(IMG_HEIGHT, IMG_WIDTH))
    # print("Overlap Factor: {}".format(overlap_fac))
    # print("Step y: {}".format(step_y))
    # print("Step y count: {}".format(y_step_c))
    # print("Remainder in y: {}".format(y_rem))
    # print("Step x: {}".format(step_x))
    # print("Step x count: {}".format(x_step_c))
    # print("Remainder in x: {}".format(x_rem))
    
    return(outputidx)
            
            
def crop_to_patch(img, cropidx, target_size = (256, 256)):
    '''
    img: input image for cropping
    cropidx: index for cropping the image
    Var: [start_y, end_y, start_x, end_x]
    '''
    
    ## crop img
    outputimg = np.zeros((cropidx.shape[0], target_size[0], target_size[1]))
    # for idx in trange(outputimg.shape[0]):
    for idx in range(outputimg.shape[0]):
        start_y = cropidx[idx, 0]
        end_y = cropidx[idx, 1]
        start_x = cropidx[idx, 2]
        end_x = cropidx[idx, 3]
        outputimg[idx] = img[start_y:end_y, start_x:end_x]
   
    return(outputimg)


def construct_from_patch(img_stack: Any, 
                         cropidx: Any,
                         target_size: Union[List[int], Tuple[int]]):
    '''
    img: input image for cropping
    IMG_HEIGHT, IMG_WIDTH: height and width for the training network
    Cropping rule: from top-left to bottom-right, row first
    '''
    
    img_patch_y = img_stack.shape[1]
    img_patch_x = img_stack.shape[2]
    img_target_size_y = target_size[0]
    img_target_size_x = target_size[1]
    # reshape the gray image
    img_stack = np.reshape(img_stack, (img_stack.shape[0], img_stack.shape[1], img_stack.shape[2])) 
    
    # create the empty array
    img_stack_repos = np.full((img_stack.shape[0], img_target_size_y, img_target_size_x), np.nan)
    
    # for idx in trange(img_stack.shape[0]):
    for idx in range(img_stack.shape[0]):
        img_stack_repos[idx, cropidx[idx, 0]:cropidx[idx, 1], 
                        cropidx[idx, 2]:cropidx[idx, 3]] = img_stack[idx, :, :]
    
    outputimg = np.nanmean(img_stack_repos, axis = 0)
    
    # print("Patch Image Shape: {}, {}".format(img_patch_y, img_patch_x))
    # print("Target Image Size: {}, {}".format(img_target_size_y, img_target_size_x))
    return(outputimg)

def create_crop_idx_whole(img_size, target_size = (256, 256), overlap_fac = 0.1):
    '''
    img_size: the size(shape) of input image
    IMG_HEIGHT, IMG_WIDTH: height and width for the training network
    Cropping rule: from top-left to bottom-right, row first
    '''
    
    img_y = img_size[0]
    img_x = img_size[1]
    IMG_HEIGHT = target_size[0]
    IMG_WIDTH = target_size[1]
    overlap_fac = overlap_fac
    
    overlap_y = round(target_size[0] * overlap_fac) #overlap pixel
    step_y = target_size[0] - overlap_y # step size    
    
    y_step_c = math.ceil((img_y - IMG_HEIGHT) / step_y) + 1
    y_rem = (img_y - IMG_HEIGHT) % step_y 

    overlap_x = round(target_size[1] * overlap_fac) #overlap pixel
    step_x = target_size[1] - overlap_x # step size    
    
    x_step_c = math.ceil((img_x - IMG_WIDTH) / step_x) + 1
    x_rem = (img_x - IMG_WIDTH) % step_x 
    
    if (IMG_HEIGHT > img_y) | (IMG_WIDTH > img_x):
        print('At least one dimension of the image is smaller than patch size.')
        return
    
    outputidx = np.empty((0, 6), int)
    
    ## create crop index
    # for imgidx_y in trange(y_step_c):  
    for imgidx_y in range(y_step_c):
        if (imgidx_y+1)%y_step_c != 0:
            start_y = imgidx_y*step_y
            end_y = imgidx_y*step_y+IMG_HEIGHT
            for imgidx_x in range(x_step_c):
                if (imgidx_x+1)%x_step_c == 0:
                    start_x = img_x-IMG_WIDTH
                    end_x = img_x
                    outputidx = np.append(outputidx,
                                          np.array([[start_y, end_y,
                                                     start_x, end_x,
                                                     imgidx_y, imgidx_x]]), axis=0)
        else: 
            start_y = img_y-IMG_HEIGHT
            end_y = img_y
            for imgidx_x in range(x_step_c): 
                if (imgidx_x+1)%x_step_c != 0:
                    start_x = imgidx_x*step_x
                    end_x = imgidx_x*step_x+IMG_WIDTH
                    outputidx = np.append(outputidx, 
                                                np.array([[start_y, end_y, 
                                                           start_x, end_x, 
                                                           imgidx_y, imgidx_x]]), axis=0)
                else:
                    start_x = img_x-IMG_WIDTH
                    end_x = img_x
                    outputidx = np.append(outputidx, 
                                                np.array([[start_y, end_y, 
                                                           start_x, end_x, 
                                                           imgidx_y, imgidx_x]]), axis=0)
         
    # print("Image Shape: {}, {}".format(img_y, img_x))
    # print("Patch size: {}, {}".format(IMG_HEIGHT, IMG_WIDTH))
    # print("Overlap Factor: {}".format(overlap_fac))
    # print("Step y: {}".format(step_y))
    # print("Step y count: {}".format(y_step_c))
    # print("Remainder in y: {}".format(y_rem))
    # print("Step x: {}".format(step_x))
    # print("Step x count: {}".format(x_step_c))
    # print("Remainder in x: {}".format(x_rem))
    
    return(outputidx)



    